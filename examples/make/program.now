#!now :f

[program]
# vim: syntax=toml
name "Now as an alternative to Make"
description "A very convoluted way of doing the same a Makefile would do much more easily."
focal_point "constants/targets/release"


[constants/targets/release]
description "now binary, release"
output_filepath "dist/now"
source_files {
    - {
        directory "cli/source/now"
        pattern "app.d"
    }
    - {
        directory "source/now"
        pattern "*.d"
    }
}
debug false
command compile


[constants/targets/debug]
description "now binary, debug"
output_filepath "dist/now.debug"
source_files {
    - {
        directory "cli/source/now"
        pattern "app.d"
    }
    - {
        directory "source/now"
        pattern "*.d"
    }
}
debug true
command compile


[logging/formats/default]

# dict (timestamp = [unixtime]) (message = $message) | json.encode | return
unixtime | as timestamp
return "$timestamp> $message"


[system_commands/hash]
parameters {
    files {
        type list
    }
}
command {
    - "md5sum"
    - $files
}

[system_commands/hash/on.return]

stack.pop | transform entry {
    # filename  hash
    split " " $entry | range | transform part {
        if (($part length) == 0) {
            skip
        } else {
            return $part
        }
    } | collect | return
}


[system_commands/gdc_bin]
parameters {
    files {
        type {
            - list
            - path
        }
    }
    output_filepath {
        type string
    }
    optimization {
        type int
        min 0
        max 3
        default 2
    }
    extra {
        type list
        default {
        }
    }
}
key_value_separator ""
option_prefix "-"
command {
    - "gdc"
    - $extra
    - "-static-libphobos"
    - "-static-libgcc"
    - "-O$optimization"
    - {
        o $output_filepath
    }
    - $files
}


[system_commands/gdc_obj]
parameters {
    file {
        type path
    }
    output_filepath {
        type string
    }
    optimization {
        type int
        min 0
        max 3
        default 2
    }
    extra {
        type list
        default {
        }
    }
}
key_value_separator ""
option_prefix "-"
command {
    - "gdc"
    - "-c"
    - $extra
    - "-static-libphobos"
    - "-static-libgcc"
    - "-Isource"
    - "-Icli/source"
    - "-O$optimization"
    - {
        o $output_filepath
    }
    - $file
}


[procedures/compile]
parameters {
    files {
        type list
    }
    output_filepath {
        type string
    }
    debug {
        type bool
        default false
    }
}

list | as extra
if $debug {
    push $extra "-fdebug"
}

json.encode $extra | md5 | as options_hash

scope "generate object files" {
    list | as object_files
    set has_new_files false
    try {
        hash $files | foreach pair {
            set (hash , input_file) $pair
            path "build/${hash}-${options_hash}.o" | as obj_file
            if (($obj_file exists) == false) {
                log "compiling $input_file into $obj_file"

                timer {
                    gdc_obj $input_file $obj_file (extra = $extra) | check
                } {
                    log "$input_file was compiled in $microseconds microseconds."
                }
                set has_new_files true
            }
            push $object_files $obj_file
        }
    }

}

scope "clean old files" {
    if $has_new_files {
        glob [path "build"] "*.o" | range | foreach filename {
            if (($object_files contains $filename) == false) {
                log "Deleting $filename ..."
                delete $filename
            }
        }
    }
}

scope "generate binary" {
    gdc_bin $object_files $output_filepath (extra = $extra) | { print }
}


[procedures/make]
parameters {
    target_name {
        type string
    }
}

log "Making $target_name ..."
get $targets $target_name | as target

scope "resolve dependencies" {
    try { get $target depends_on } { list } | range | foreach dependency {
        make $dependency
    }
}

scope "compile" {
    get $target command | as command
    list | as source_files

    get $target source_files | range | foreach pair {
        get $pair directory | path | as directory
        get $pair pattern | as pattern

        glob.depth $directory $pattern | range | foreach file {
            push $source_files $file
        }
    }

    get $target output_filepath | path | as output_filepath
    try {
        timer {
            call $command
                . $source_files
                . $output_filepath
                . (debug = ($target . debug))
                | foreach line {
                    log "$command: $line"
                }
        } {
            log "$output_filepath was compiled in $miliseconds miliseconds."
        }
    } {
        log ">>>>> ERROR: $error"
        return $error
    }
    log "compilation finished."
}

log "make $target_name finished."


[commands/build/on.call]
description "Verify if the user is running from inside the examples directory."

split "/" ($env . "PWD") | as pwd
length $pwd | as length
get $pwd ($length - 1) | as cwd
if (($cwd == "examples") || ($cwd == "make")) {
    print "Do not run this program from inside the examples directory!"
    print "Go to the repository root and run it this way:"
    print "    cat examples/make/program.now | now :stdin build"
    print "--------------------------------------------------------"
    exit 1
}

[commands/build]
description "Build now binary"
parameters {
    target {
        description "debug/release"
        type string
        default "release"
        choices {
            - "release"
            - "debug"
        }
    }
}

make $target


[commands/clean]

glob [path "dist/*"] | foreach file { print delete $file }
