[program]
# vim: syntax=now
name "Now Document Example"
description "Show how the document syntax works."


[program/on.error]

print "The program terminated with some error."
return $error


[configuration/hello]
salute_word {
    type string
    default "Hello"
}


[constants/math]
pi 3.1415


[constants/test]
ignore {
    - "http"
    - "make"
    - "named-scopes"
    - "plantuml"
    - "signals"
}


[logging/formats/default]
description "This section defines how the `log` command will behave"


dict (timestamp = [unixtime]) (message = $message) | json.encode | return


[system_commands/list_dir]
parameters {
    path {
        type string
    }
    options {
        type string
        default "-1"
    }
}
command {
    - "ls"
    - $options
    - $path
}


[system_commands/now]
parameters {
    path {
        type string
    }
}
workdir $path
command {
    - "now"
    - "run"
}


[shells/bash]
# This configuration is optional.
# The following values are the default ones:
command {
    - "bash"
    - "-c"
    - $script_body
    - $script_name
}


[shells/bash/scripts/find_device]
parameters {
    name {
        type string
    }
}

/bin/ls -lh /dev | grep "$name"


[procedures/hello]
parameters {
    name {
        type string
        description "The name of whoever is going to be saluted"
    }
    times {
        type int
        description "How many times the procedure should salute"
        default 1
    }
}

# Configuration variables are global, so you only
# need to specify the full "path" when really needed:
# print ($configuration . hello . salute_word) ", $name!"
print "# hello"
print "arguments: name=$name times=$times"
print "configuration: hello . salute_word: " ($hello . salute_word)
get $hello salute_word | as salute_word
range.silent 1 $times | {
    print ">>> $salute_word, $name!"
}


[procedures/error_handling]

error "Test error" 123 "generic-error"
print "POST ERROR: we should never reach this command."

[procedures/error_handling/on.error]

print "The following error occurred and was handled:"
print "    $error"


[commands/hello]
description "Say hello to someone."
parameters {
    # Some stuff seems repetitive, but this is just
    # because we are declaring another procedure,
    # which in real life would be unnecessary.
    name {
        type string
        description "The name of whoever is going to be saluted"
        default "World"
    }
    salute_word {
        type string
        description "The word used to salute"
        default "Hello"
    }
}

print "commands/hello: name=$name salute_word=$salute_word"

print "calling hello only with a name..."
hello $name
print

print "calling hello with positional and named arguments..."
hello $name (salute_word = $salute_word)
print

print "calling hello with times = 3 and a different salute word..."
hello $name (times = 3) (salute_word = "hi")


[commands/pi]
description "Tells the value of pi using program contants."
parameters {}

print "math/pi is " ($math . pi)


[commands/e]
description "Shows how errors can be handled."

error_handling


[commands/exit]
description "Exits the program with an error code."
parameters {
    code {
        type int
        default 123
    }
}

to.int $code | as n
if (($n > 127) || ($n < 0)) {
    error "The exit code should be between zero and 127"
}

print "Exiting the program with code ${n}..."
exit $n


[commands/ls/on.error]

print "list-dir returned an error: $error"
return $error


[commands/ls]
parameters {
    path {
        type string
        default "."
    }
}

list_dir $path | { print }


[commands/find_device/on.call]

print "Starting find_device..."

[commands/find_device]
description "Scans /dev for devices matching a name."
parameters {
    name {
        type string
    }
}

find_device $name | { print }

[commands/find_device/on.return]

print "find_device finished."


[shells/bash/scripts/make]
parameters {
    target {
        type string
    }
}

cat examples/make/program.now | now :stdin build $target


[commands/make]
description "Compiles Now"
parameters {
    target {
        type string
        default "release"
        choices {
            - "release"
            - "debug"
        }
    }
}

timer {
    try {
        make $target | foreach line {
            print "> $line"
        }
        log "Made successfully."
    }
} {
    print "Made successfully in $miliseconds miliseconds."
}


[commands/test]
description "Run all the examples."

try {
    list_dir "examples" | foreach directory {
        if (($test . ignore) contains $directory) {
            print "skipping $directory"
            continue
        }
        print "Testing examples/${directory}..."
        now "examples/$directory" | check
    }
}


[commands/run]
description "Show some help text."

print.yellow "Try running `now` without any arguments to see"
print.yellow "a list of available subcommands for this project."
